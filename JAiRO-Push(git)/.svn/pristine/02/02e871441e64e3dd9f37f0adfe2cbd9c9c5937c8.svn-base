package com.nexus.push.service;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileReader;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.security.InvalidKeyException;
import java.security.KeyFactory;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.Signature;
import java.security.SignatureException;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.KeySpec;
import java.security.spec.PKCS8EncodedKeySpec;
import java.util.Arrays;

import javax.net.ssl.HttpsURLConnection;
import javax.servlet.ServletContext;
import javax.servlet.http.HttpServletRequest;

import org.apache.commons.codec.binary.Base64;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.PropertySource;
import org.springframework.core.env.Environment;
import org.springframework.stereotype.Service;

import com.google.api.client.googleapis.auth.oauth2.GoogleCredential;
import com.nexus.push.domain.HttpStatusDomain;
import com.nexus.push.domain.PushDomain;
import com.nexus.push.httpClient.HttpClient;
import com.nexus.push.util.fcmApnsTokenHandler;
import com.turo.pushy.apns.ApnsClient;
import com.turo.pushy.apns.ApnsClientBuilder;
import com.turo.pushy.apns.PushNotificationResponse;
import com.turo.pushy.apns.auth.ApnsSigningKey;
import com.turo.pushy.apns.util.ApnsPayloadBuilder;
import com.turo.pushy.apns.util.SimpleApnsPushNotification;
import com.turo.pushy.apns.util.TokenUtil;
import com.turo.pushy.apns.util.concurrent.PushNotificationFuture;
import com.turo.pushy.apns.util.concurrent.PushNotificationResponseListener;

import io.netty.channel.EventLoop;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.handler.codec.http2.Http2SecurityUtil;
import io.netty.handler.ssl.ApplicationProtocolConfig;
import io.netty.handler.ssl.ApplicationProtocolConfig.Protocol;
import io.netty.handler.ssl.ApplicationProtocolConfig.SelectedListenerFailureBehavior;
import io.netty.handler.ssl.ApplicationProtocolConfig.SelectorFailureBehavior;
import io.netty.handler.ssl.ApplicationProtocolNames;
import io.netty.handler.ssl.OpenSsl;
import io.netty.handler.ssl.SslContext;
import io.netty.handler.ssl.SslContextBuilder;
import io.netty.handler.ssl.SslProvider;
import io.netty.handler.ssl.SupportedCipherSuiteFilter;
import io.netty.handler.ssl.util.InsecureTrustManagerFactory;
import lombok.extern.slf4j.Slf4j;

@Configuration
@Service
@PropertySource("classpath:META-INF/push.properties")
@Slf4j
public class PushServiceImpl implements PushService{

	@Autowired
	Environment env;
	
	@Autowired
	ServletContext servletContext;

	HttpClient httpclient = new HttpClient();
	fcmApnsTokenHandler tokenHandler = new fcmApnsTokenHandler();
	
	@Override
	public String fcmPush(PushDomain pushDomain) throws Exception{
		logger.info("FCM PUSH START !!!!!");
		//fcm token setting
		pushDomain.setKey_path(env.getProperty("fcm.keyPath"));
		pushDomain.setKeyFile_name(env.getProperty("fcm.key.fileName"));
		tokenHandler.fcmTokenSet(pushDomain, servletContext);
		
		//fcm POST data setting
		logger.info("FCM PUSH DATA MAKE START !!!!!");
        JSONObject notificationObject = new JSONObject();
        JSONObject dataObject = new JSONObject();
        JSONObject messageObject = new JSONObject();
        dataObject.put("body", pushDomain.getMessage()); // Notification body
        dataObject.put("title", pushDomain.getTitle());
        notificationObject.put("token", pushDomain.getDevice_token()); 
        notificationObject.put("notification", dataObject);
        messageObject.put("message", notificationObject); // deviceID
        logger.info("FCM PUSH DATA : {}",messageObject.toString());        
        pushDomain.setPost_data(messageObject.toString());
        logger.info("FCM PUSH DATA MAKE END !!!!!");
        
        //fcm url setting
        pushDomain.setFcm_start_url(env.getProperty("fcm.start.url"));
        pushDomain.setFcm_end_url(env.getProperty("fcm.end.url"));
        pushDomain.setFcm_port(Integer.parseInt(env.getProperty("fcm.port")));
        pushDomain.setRequest_type(env.getProperty("fcm.req.type"));
        pushDomain.setFcm_full_url(
        						pushDomain.getRequest_type()+
        						pushDomain.getFcm_start_url()+
        						pushDomain.getFcm_end_url()
        					  );
        return httpclient.httpStart(pushDomain);
	}
	
	@Override
	public HttpStatusDomain apnsPush(PushDomain pushDomain) throws Exception{
		
		logger.info("APNS PUSH START !!!!!");
		//apns token setting
		pushDomain.setKey_id(env.getProperty("apns.keyId"));
		pushDomain.setTeam_id(env.getProperty("apns.teamId"));
		pushDomain.setKey_path(env.getProperty("apns.keyPath"));
		pushDomain.setKeyFile_name(env.getProperty("apns.p8.fileName"));
		tokenHandler.apnsTokenSet(pushDomain, servletContext);
		
		//apns POST data setting
		logger.info("APNS PUSH DATA MAKE START !!!!!");
		JSONObject apsObject = new JSONObject();
		JSONObject alertObject = new JSONObject();
		JSONObject dataObject = new JSONObject();
		dataObject.put("title", pushDomain.getTitle());
		dataObject.put("body", pushDomain.getMessage());
		alertObject.put("alert", dataObject);
		apsObject.put("aps", alertObject);
		logger.info("APNS PUSH DATA : {}",apsObject.toString());
        pushDomain.setPost_data(apsObject.toString());
        logger.info("APNS PUSH DATA MAKE END !!!!!");
        
        //apns topic setting
        pushDomain.setApns_topic(env.getProperty("apns.topic"));
        
        //apns url setting
        pushDomain.setApns_start_url(env.getProperty("apns.start.url"));
        //pushDomain.setApns_start_url2(env.getProperty("apns.start.url2"));
        pushDomain.setApns_end_url(env.getProperty("apns.end.url"));
        pushDomain.setApns_port(Integer.parseInt(env.getProperty("apns.port")));
        pushDomain.setRequest_type(env.getProperty("apns.req.type"));
        
		return httpclient.http2Start(pushDomain);
	}
	
	/*public HttpURLConnection fcmPush(PushDomain pushdomain, HttpServletRequest request) throws Exception{
		logger.info("getMessage : "+pushdomain.getMessage());
		logger.info("getTitle : "+pushdomain.getTitle());
		logger.info("getToken : "+pushdomain.getToken());
		logger.info("key : "+env.getProperty("fcm.push.key"));
		logger.info("url : "+env.getProperty("fcm.push.url"));
		URL url=null;
		OutputStreamWriter wr = null;
		
		url=new URL(env.getProperty("fcm.push.url"));
		HttpURLConnection conn=(HttpURLConnection)url.openConnection();
		logger.info("openconnection ok");
		conn.setConnectTimeout(3000);
		conn.setReadTimeout(3000);
		conn.setUseCaches(false);
		conn.setDoInput(true);
		conn.setDoOutput(true);
		conn.setRequestMethod("POST");
		//기존 HTTP 방식
		//conn.setRequestProperty("Authorization", "key =" + env.getProperty("fcm.push.key"));
		//HTTP v1 방식
		conn.setRequestProperty("Authorization", "Bearer " + getAccessToken(request));
        conn.setRequestProperty("Content-Type", "application/json; UTF-8");
        logger.info("connection setting ok");
        JSONObject json = new JSONObject();
        JSONObject info = new JSONObject();
        
        info.put("body", pushdomain.getMessage()); // Notification body
        info.put("title", pushdomain.getTitle());
        json.put("notification", info);
        json.put("to", pushdomain.getToken()); // deviceID

        wr = new OutputStreamWriter(conn.getOutputStream(), "UTF-8");
        wr.write(json.toString());
        wr.flush();
        wr.close();
        logger.info("send ok");
		return conn;
	}*/
	
	/*public boolean fcmPush(PushDomain pushdomain){
		logger.info("getMessage : "+pushdomain.getMessage());
		logger.info("getTitle : "+pushdomain.getTitle());
		logger.info("getToken : "+pushdomain.getToken());
		logger.info("key : "+env.getProperty("fcm.push.key"));
		logger.info("url : "+env.getProperty("fcm.push.url"));
		try {
			OkHttpClient client = new OkHttpClient.Builder()
					.connectTimeout(3, TimeUnit.MINUTES)
					.followRedirects(true)
					.readTimeout(3, TimeUnit.MINUTES)
					.retryOnConnectionFailure(false)
					.writeTimeout(3, TimeUnit.MINUTES)
					.connectionPool(new ConnectionPool(5, 1, TimeUnit.SECONDS))
					.build();
			
			JSONObject json = new JSONObject();
	        JSONObject info = new JSONObject();
	        
	        info.put("body", pushdomain.getMessage()); // Notification body
	        info.put("title", pushdomain.getTitle());
	        json.put("notification", info);
	        json.put("to", pushdomain.getToken()); // deviceID
	        
	        Request request = new Request.Builder()
	        		.addHeader("Authorization", "key =" + env.getProperty("fcm.push.key"))
	        		.addHeader("Content-Type", "application/json; UTF-8")
	        		.url(env.getProperty("fcm.push.url"))
	        		.post(RequestBody.create(MediaType.parse("application/json"), json.toString()))
	        		.build();
	        Response res = client.newCall(request).execute();
	        
	        logger.info("reqest : "+request.toString());
	        logger.info("res : "+res.toString());
	        return true;
		}catch(Exception e) {
			e.printStackTrace();
		}
		return false;
		
        
	}*/
	
	
	
	/*public boolean apnsPush(PushDomain pushdomain) {
		logger.info("getMessage : "+pushdomain.getMessage());
		logger.info("getTitle : "+pushdomain.getTitle());
		logger.info("getToken : "+pushdomain.getToken());
		logger.info("url : "+env.getProperty("apns.dev.url")+":"+env.getProperty("apns.port")+env.getProperty("apns.dev.url.endpoint")+pushdomain.getToken());
		try {
			final TrustManager[] certs = new TrustManager[]{new X509TrustManager() {
				
				@Override
				public X509Certificate[] getAcceptedIssuers() {
					// TODO Auto-generated method stub
					return new java.security.cert.X509Certificate[]{};
				}
				
				@Override
				public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
					// TODO Auto-generated method stub
					
				}
				
				@Override
				public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
					// TODO Auto-generated method stub
					
				}
			}
			};
	 
	        SSLContext ctx = SSLContext.getInstance("TLSv1.2");
		
	        ctx.init(null, certs, new SecureRandom());
	        final SSLSocketFactory sslSocketFactory = ctx.getSocketFactory();
	        logger.info("SSLSocketFactory : "+sslSocketFactory);
	        logger.info("X509TrustManager : "+(X509TrustManager)certs[0]);
	        OkHttpClient client = new OkHttpClient.Builder()
	        		.sslSocketFactory(sslSocketFactory, (X509TrustManager)certs[0])
            		.hostnameVerifier(new HostnameVerifier() {
						@Override
						public boolean verify(String hostname, SSLSession session) {
							// TODO Auto-generated method stub
							return true;
						}
					})
            		.connectTimeout(3, TimeUnit.MINUTES)
            		.followRedirects(true)
            		.readTimeout(3, TimeUnit.MINUTES)
            		.retryOnConnectionFailure(false)
            		.writeTimeout(3, TimeUnit.MINUTES)
            		.connectionPool(new ConnectionPool(5, 1, TimeUnit.SECONDS))
            		.build();
	            OkHttpClient.Builder builder = new OkHttpClient.Builder();
	            		builder.sslSocketFactory(ctx.getSocketFactory(), (X509TrustManager)certs[0]);
	            		builder.hostnameVerifier(new HostnameVerifier() {
							@Override
							public boolean verify(String hostname, SSLSession session) {
								// TODO Auto-generated method stub
								return true;
							}
						});
	            		builder.connectTimeout(3, TimeUnit.MINUTES);
	            		builder.followRedirects(true);
	            		builder.readTimeout(3, TimeUnit.MINUTES);
	            		builder.retryOnConnectionFailure(false);
	            		builder.writeTimeout(3, TimeUnit.MINUTES);
	            		builder.connectionPool(new ConnectionPool(5, 1, TimeUnit.SECONDS));

			OkHttpClient client = builder.build();
			
			JSONObject json = new JSONObject();
	        JSONObject info = new JSONObject();
	        
	        info.put("alert", pushdomain.getMessage());
	        json.put("aps", info);
	        logger.info("data : "+json.toString());
	        String apns_token = getApnsToken();
	        Request request = new Request.Builder()
	        		.addHeader("Content-Length", json.toString().getBytes(StandardCharsets.UTF_8).length+"")
	        		.addHeader("Content-Type", "application/x-www-form-urlencoded; UTF-8")
	        		.addHeader("Authorization", "Bearer " + apns_token)
	        		.addHeader("apns-topic", env.getProperty("apns.topic"))
	        		.url(env.getProperty("apns.dev.url")+":"+env.getProperty("apns.port")+env.getProperty("apns.dev.url.endpoint")+pushdomain.getToken())
	        		.post(RequestBody.create(MediaType.parse("application/x-www-form-urlencoded"), json.toString()))
	        		.build();
	        Response res = client.newCall(request).execute();
	        
	        logger.info("reqest : "+request.toString());
	        logger.info("res : "+res.toString());
	        return true;
		}catch(Exception e) {
			e.printStackTrace();
		}
		return false;
		
        
		
		HttpClient client=HttpClient.newHttpClient();
		try {
			HttpResponse<String> response=client.send(
					HttpRequest
					.newBuilder(new URI("https://api.sandbox.push.apple.com:443"))
					.header("Authorization", "Bearer "+env.getProperty("apns.push.token"))
					.POST(BodyProcessor.fromString(""))
					.build(),
					BodyHandler.asString()
			);
			int statusCode=response.statusCode();
			String body=response.body();
		}catch(Exception e) {
			
		}
		return null;
	}*/
	
	
	//PUSHY 라이브러리 사용(APNS전용)
	/*public void apnsPush(PushDomain pushDomain) {
		
		try {
			final ApnsClient apnsClient = new ApnsClientBuilder()
			        .setApnsServer(ApnsClientBuilder.DEVELOPMENT_APNS_HOST)
			        .setSigningKey(ApnsSigningKey.loadFromPkcs8File(new File(servletContext.getRealPath("/WEB-INF/classes/META-INF")+"/AuthKey_3HAT2737TZ.p8"),
			                "43S356U979", "3HAT2737TZ"))
			        .build();
			
			final SimpleApnsPushNotification pushNotification;
		    final ApnsPayloadBuilder payloadBuilder = new ApnsPayloadBuilder();
		    payloadBuilder.setAlertBody("Example!");

		    final String payload = payloadBuilder.buildWithDefaultMaximumLength();
		    final String token = TokenUtil.sanitizeTokenString("fe06b5d75345dbec5a77b3e0c78bbeda0dda847107e4829075b6647a45097355");

		    pushNotification = new SimpleApnsPushNotification(token, "com.nexus.webRTC", payload);
		    final PushNotificationFuture<SimpleApnsPushNotification, PushNotificationResponse<SimpleApnsPushNotification>>
		    sendNotificationFuture = apnsClient.sendNotification(pushNotification);
		    
		    final PushNotificationResponse<SimpleApnsPushNotification> pushNotificationResponse =
		            sendNotificationFuture.get();

		    if (pushNotificationResponse.isAccepted()) {
		        logger.info("Push notification accepted by APNs gateway.");
		    } else {
		    	logger.info("Notification rejected by the APNs gateway: " +
		                pushNotificationResponse.getRejectionReason());

		        if (pushNotificationResponse.getTokenInvalidationTimestamp() != null) {
		        	logger.info("\t…and the token is invalid as of " +
		                pushNotificationResponse.getTokenInvalidationTimestamp());
		        }
		    }
		    sendNotificationFuture.addListener(new PushNotificationResponseListener<SimpleApnsPushNotification>() {

		        @Override
		        public void operationComplete(final PushNotificationFuture<SimpleApnsPushNotification, PushNotificationResponse<SimpleApnsPushNotification>> future) throws Exception {
		            // When using a listener, callers should check for a failure to send a
		            // notification by checking whether the future itself was successful
		            // since an exception will not be thrown.
		            if (future.isSuccess()) {
		                final PushNotificationResponse<SimpleApnsPushNotification> pushNotificationResponse =
		                        sendNotificationFuture.getNow();

		                // Handle the push notification response as before from here.
		            } else {
		                // Something went wrong when trying to send the notification to the
		                // APNs gateway. We can find the exception that caused the failure
		                // by getting future.cause().
		                future.cause().printStackTrace();
		            }
		        }
		    });
		}catch(Exception e) {
			e.printStackTrace();
		}
	}*/
	
}
